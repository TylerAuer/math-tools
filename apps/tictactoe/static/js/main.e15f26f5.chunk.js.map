{"version":3,"sources":["calculateWinner.js","index.js"],"names":["calculateWinner","squares","lines","i","boardSize","Math","floor","inARowToWin","squaresArr","j","push","negSlopeDiagEndIndex","posSlopeDiagEndIndex","winningSquares","line","firstSquareVal","winCheck","length","Square","props","isWinningSquare","classList","forEach","element","includes","index","className","onClick","value","Board","this","key","row","k","rowSquares","renderSquare","React","Component","Game","state","history","Array","fill","lastMoveIndex","stepNumber","xIsNext","slice","setState","concat","step","status","current","winner","moves","map","move","lastMoveLocation","whoWent","whoWentClass","desc","jumpTo","handleClick","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.e15f26f5.chunk.js","sourcesContent":["import { boardSize, inARowToWin } from \"./index\";\n\n/**\n * returns false if no winner\n * returns an array of arrays listing the \"lines\" of winning square indexes\n * @param {array} squares = current state of the game board\n */\nexport function calculateWinner(squares) {\n  // generate list of cells check for winning based on board size\n  let lines = [];\n  for (let i = 0; i < boardSize ** 2; i++) {\n    // adds arrays of winning row indexes to check\n    if (\n      Math.floor(i / boardSize) ===\n      Math.floor((i + inARowToWin - 1) / boardSize)\n    ) {\n      const squaresArr = [];\n      for (let j = i; j < i + inARowToWin; j++) {\n        squaresArr.push(j);\n      }\n      lines.push(squaresArr);\n    }\n    // adds arrays of winning column indexes to check\n    if (i + boardSize * (inARowToWin - 1) < boardSize ** 2) {\n      const squaresArr = [];\n      for (let j = 0; j < inARowToWin; j++) {\n        squaresArr.push(i + j * boardSize);\n      }\n      lines.push(squaresArr);\n    }\n    // adds negative slope diagonals\n    const negSlopeDiagEndIndex =\n      i + (boardSize * (inARowToWin - 1) + (inARowToWin - 1));\n    // check if last index is small enough\n    if (negSlopeDiagEndIndex < boardSize ** 2) {\n      // check if last index is too far right\n      if (\n        Math.floor(i / boardSize) + (inARowToWin - 1) ===\n        Math.floor(negSlopeDiagEndIndex / boardSize)\n      ) {\n        const squaresArr = [];\n        for (let j = 0; j < inARowToWin; j++) {\n          squaresArr.push(i + j * boardSize + j);\n        }\n        lines.push(squaresArr);\n      }\n    }\n    // adds positive slope diagonals\n    const posSlopeDiagEndIndex =\n      i + (boardSize * (inARowToWin - 1) - (inARowToWin - 1));\n    // check if last index is small enough\n    if (posSlopeDiagEndIndex < boardSize ** 2) {\n      // check if last index is too far left\n      if (\n        Math.floor(i / boardSize) + (inARowToWin - 1) ===\n        Math.floor(posSlopeDiagEndIndex / boardSize)\n      ) {\n        const squaresArr = [];\n        for (let j = 0; j < inARowToWin; j++) {\n          squaresArr.push(i + j * boardSize - j);\n        }\n        lines.push(squaresArr);\n      }\n    }\n  }\n  // check if any set of squares in lines arrays all match X or O\n  let winningSquares = [];\n  for (const line of lines) {\n    const firstSquareVal = squares[line[0]];\n    let winCheck = true;\n    // ignores lines where first square is null\n    if (firstSquareVal === null) {\n      winCheck = false;\n    }\n    // checks if squares in line match first square\n    for (let j = 1; j < inARowToWin; j++) {\n      if (squares[line[j]] !== firstSquareVal) {\n        winCheck = false;\n      }\n    }\n    // if a line has all matching symbols add results to winning squares array\n    if (winCheck) {\n      winningSquares.push(line);\n    }\n  }\n  // return false if no winning line(s) are found\n  if (winningSquares.length === 0) {\n    return false;\n  }\n\n  // return array of winning cells if some are found\n  return winningSquares;\n}\n","// Suggested extensions:\n\n// [X] Display the location for each move in the format (col, row) in the move history list.\n// [X] Rewrite Board to use two loops to make the squares instead of hard coding them.\n// [X] Generalize to n*n sized board\n// [ ] Prompt user for boardSize and inARow Goal with error checking\n// [X] When someone wins, highlight the n squares that caused the win.\n// [ ] Bold the currently selected item in the move list.\n// [ ] Add a toggle button that lets you sort the moves in either ascending or descending order.\n// [ ] When no one wins, display a message about the result being a draw.\n// [ ] Check if a winner is still possible, Cat's game\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport { calculateWinner } from \"./calculateWinner\";\n\nexport const boardSize = 10;\nexport const inARowToWin = 5; // >= 1\n\n// uses function instead of class because it is only rendering information, no state\nfunction Square(props) {\n  let isWinningSquare = false;\n  let classList = \"square\";\n\n  // if there is a winner\n  if (props.winningSquares) {\n    // check if this square is in any of the winning lines\n    props.winningSquares.forEach(element => {\n      if (element.includes(props.index)) {\n        isWinningSquare = true;\n      }\n    });\n  }\n  if (isWinningSquare) {\n    classList += \" winning-square\";\n  }\n\n  return (\n    // {props.onClick} runs the onClick function passed from Game then Board component\n    <button className={classList} onClick={props.onClick}>\n      {props.value}\n    </button>\n  );\n}\n\nclass Board extends React.Component {\n  renderSquare(i) {\n    return (\n      <Square\n        value={this.props.squares[i]}\n        onClick={() => this.props.onClick(i)}\n        key={i}\n        index={i}\n        winningSquares={this.props.winningSquares}\n      />\n    );\n  }\n\n  render() {\n    const row = [];\n    let k = 0;\n    for (let i = 0; i < boardSize; i++) {\n      const rowSquares = [];\n      for (let j = 0; j < boardSize; j++) {\n        rowSquares.push(this.renderSquare(boardSize * i + j));\n        k++;\n      }\n      row.push(\n        <div key={k} className=\"board-row\">\n          {rowSquares}\n        </div>\n      );\n    }\n    return <div>{row}</div>;\n  }\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      history: [\n        {\n          squares: Array(boardSize ** 2).fill(null),\n          lastMoveIndex: null\n        }\n      ],\n      stepNumber: 0,\n      xIsNext: true\n    };\n  }\n\n  handleClick(i) {\n    const history = this.state.history.slice(0, this.state.stepNumber + 1);\n    const current = history[history.length - 1];\n    const squares = current.squares.slice();\n\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    squares[i] = this.state.xIsNext ? \"X\" : \"O\";\n    this.setState({\n      history: history.concat([\n        {\n          squares: squares,\n          lastMoveIndex: i\n        }\n      ]),\n      stepNumber: history.length,\n      xIsNext: !this.state.xIsNext\n    });\n  }\n\n  jumpTo(step) {\n    this.setState({\n      stepNumber: step,\n      xIsNext: step % 2 === 0\n    });\n  }\n\n  render() {\n    const history = this.state.history;\n    const current = history[this.state.stepNumber];\n    const winner = calculateWinner(current.squares);\n\n    let status;\n    if (winner) {\n      status = this.state.xIsNext ? \"O Wins\" : \"X Wins\";\n    } else {\n      status = \"Next player: \" + (this.state.xIsNext ? \"X\" : \"O\");\n    }\n\n    const moves = history.map((step, move) => {\n      // generates ( #, # ) for the given move\n      const lastMoveLocation =\n        \" ( \" +\n        (1 + Math.floor(step.lastMoveIndex / boardSize)) +\n        \", \" +\n        ((step.lastMoveIndex % boardSize) + 1) +\n        \" )\";\n      // determines who went and sets the class\n      const whoWent = move % 2 === 0 ? \"O\" : \"X\";\n      const whoWentClass = whoWent === \"X\" ? \"xMove\" : \"oMove\";\n\n      // button text for who went\n      const desc = move\n        ? \"Go to move #\" + move + \" by \" + whoWent + lastMoveLocation\n        : \"Go to game start\";\n\n      return (\n        <li key={move}>\n          <button className={whoWentClass} onClick={() => this.jumpTo(move)}>\n            {desc}\n          </button>\n        </li>\n      );\n    });\n\n    return (\n      <div className=\"game justify-content-center\">\n        <div className=\"game-board\">\n          <Board\n            squares={current.squares}\n            winningSquares={winner}\n            onClick={i => this.handleClick(i)}\n          />\n        </div>\n        <div className=\"game-info\">\n          <div>{status}</div>\n          <ol>{moves}</ol>\n        </div>\n      </div>\n    );\n  }\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById(\"root\"));\n"],"sourceRoot":""}